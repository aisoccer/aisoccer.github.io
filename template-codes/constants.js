var PLAYERS_P1 = 
'#!/usr/bin/env python3\n'
+ '\n'
+ '# Author(s): Taeyoung Kim, Chansol Hong, Luiz Felipe Vecchietti\n'
+ '# Maintainer: Chansol Hong (cshong@rit.kaist.ac.kr)\n'
+ '\n'
+ 'import os\n'
+ 'import sys\n'
+ '\n'
+ 'sys.path.append(os.path.dirname(os.path.realpath(__file__)) + \'/../common\')\n'
+ 'try:\n'
+ '    from participant import Game, Frame\n'
+ 'except ImportError as err:\n'
+ '    print(\'player_rulebasedC: "participant" module cannot be imported:\', err)\n'
+ '    raise\n'
+ '\n'
+ 'import math\n'
+ '\n'
+ 'import helper\n'
+ 'from action import ActionControl\n'
+ '\n'
+ '#reset_reason\n'
+ 'NONE = Game.NONE\n'
+ 'GAME_START = Game.GAME_START\n'
+ 'SCORE_MYTEAM = Game.SCORE_MYTEAM\n'
+ 'SCORE_OPPONENT = Game.SCORE_OPPONENT\n'
+ 'GAME_END = Game.GAME_END\n'
+ 'DEADLOCK = Game.DEADLOCK\n'
+ 'GOALKICK = Game.GOALKICK\n'
+ 'CORNERKICK = Game.CORNERKICK\n'
+ 'PENALTYKICK = Game.PENALTYKICK\n'
+ 'HALFTIME = Game.HALFTIME\n'
+ 'EPISODE_END = Game.EPISODE_END\n'
+ '\n'
+ '#game_state\n'
+ 'STATE_DEFAULT = Game.STATE_DEFAULT\n'
+ 'STATE_KICKOFF = Game.STATE_KICKOFF\n'
+ 'STATE_GOALKICK = Game.STATE_GOALKICK\n'
+ 'STATE_CORNERKICK = Game.STATE_CORNERKICK\n'
+ 'STATE_PENALTYKICK = Game.STATE_PENALTYKICK\n'
+ '\n'
+ '#coordinates\n'
+ 'MY_TEAM = Frame.MY_TEAM\n'
+ 'OP_TEAM = Frame.OP_TEAM\n'
+ 'BALL = Frame.BALL\n'
+ 'X = Frame.X\n'
+ 'Y = Frame.Y\n'
+ 'Z = Frame.Z\n'
+ 'TH = Frame.TH\n'
+ 'ACTIVE = Frame.ACTIVE\n'
+ 'TOUCH = Frame.TOUCH\n'
+ 'BALL_POSSESSION = Frame.BALL_POSSESSION\n'
+ '\n'
+ 'class Goalkeeper:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity, robot_id=0):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '        self.id = robot_id\n'
+ '        self.gk_index = 0\n'
+ '        self.d1_index = 1\n'
+ '        self.d2_index = 2\n'
+ '        self.f1_index = 3\n'
+ '        self.f2_index = 4\n'
+ '        self.target_robot_id = self.gk_index\n'
+ '        self.action = ActionControl(self.id, max_linear_velocity)\n'
+ '        self.robot_height = 0.421\n'
+ '\n'
+ '    def move(self, idx, idx_opp, defense_angle, attack_angle, cur_posture, cur_posture_opp, \n'
+ '            prev_posture, prev_posture_opp, prev_ball, cur_ball, predicted_ball, reset_reason, game_state):\n'
+ '        \n'
+ '        self.action.update_state(cur_posture, prev_posture, cur_ball, prev_ball, reset_reason)\n'
+ '        \n'
+ '        action = None\n';

var PLAYERS_P2 = 
'\n'
+ '        return action if action != None else self.action.stop()\n'
+ '\n'
+ 'class Defender_1:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity, robot_id=1):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '        self.id = robot_id\n'
+ '        self.gk_index = 0\n'
+ '        self.d1_index = 1\n'
+ '        self.d2_index = 2\n'
+ '        self.f1_index = 3\n'
+ '        self.f2_index = 4\n'
+ '        self.target_robot_id = self.d1_index\n'
+ '        self.action = ActionControl(self.id, max_linear_velocity)\n'
+ '        self.robot_height = 0.421\n'
+ '\n'
+ '    def move(self, idx, idx_opp, defense_angle, attack_angle, cur_posture, cur_posture_opp, \n'
+ '            prev_posture, prev_posture_opp, prev_ball, cur_ball, predicted_ball, reset_reason, game_state):\n'
+ '        \n'
+ '        self.action.update_state(cur_posture, prev_posture, cur_ball, prev_ball, reset_reason)\n'
+ '        \n'
+ '        action = None\n';

var PLAYERS_P3 = 
'\n'
+ '        return action if action != None else self.action.stop()\n'
+ '\n'
+ 'class Defender_2:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity, robot_id=2):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '        self.id = robot_id\n'
+ '        self.gk_index = 0\n'
+ '        self.d1_index = 1\n'
+ '        self.d2_index = 2\n'
+ '        self.f1_index = 3\n'
+ '        self.f2_index = 4\n'
+ '        self.target_robot_id = self.d2_index\n'
+ '        self.action = ActionControl(self.id, max_linear_velocity)\n'
+ '        self.robot_height = 0.421\n'
+ '\n'
+ '    def move(self, idx, idx_opp, defense_angle, attack_angle, cur_posture, cur_posture_opp, \n'
+ '            prev_posture, prev_posture_opp, prev_ball, cur_ball, predicted_ball, reset_reason, game_state):\n'
+ '        \n'
+ '        self.action.update_state(cur_posture, prev_posture, cur_ball, prev_ball, reset_reason)\n'
+ '\n'
+ '        action = None\n';

var PLAYERS_P4 = 
'\n'
+ '        return action if action != None else self.action.stop()\n'
+ '\n'
+ 'class Forward_1:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity, robot_id=3):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '        self.id = robot_id\n'
+ '        self.gk_index = 0\n'
+ '        self.d1_index = 1\n'
+ '        self.d2_index = 2\n'
+ '        self.f1_index = 3\n'
+ '        self.f2_index = 4\n'
+ '        self.target_robot_id = self.f1_index\n'
+ '        self.action = ActionControl(self.id, max_linear_velocity)\n'
+ '        self.robot_height = 0.421\n'
+ '\n'
+ '    def move(self, idx, idx_opp, defense_angle, attack_angle, cur_posture, cur_posture_opp, \n'
+ '            prev_posture, prev_posture_opp, prev_ball, cur_ball, predicted_ball, reset_reason, game_state):\n'
+ '        \n'
+ '        self.action.update_state(cur_posture, prev_posture, cur_ball, prev_ball, reset_reason)\n'
+ '        \n'
+ '        action = None\n';

var PLAYERS_P5 = 
'\n'
+ '        return action if action != None else self.action.stop()\n'
+ '\n'
+ 'class Forward_2:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity, robot_id=4):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '        self.id = robot_id\n'
+ '        self.gk_index = 0\n'
+ '        self.d1_index = 1\n'
+ '        self.d2_index = 2\n'
+ '        self.f1_index = 3\n'
+ '        self.f2_index = 4\n'
+ '        self.target_robot_id = self.f2_index\n'
+ '        self.action = ActionControl(self.id, max_linear_velocity)\n'
+ '        self.robot_height = 0.421\n'
+ '\n'
+ '    def move(self, idx, idx_opp, defense_angle, attack_angle, cur_posture, cur_posture_opp, \n'
+ '            prev_posture, prev_posture_opp, prev_ball, cur_ball, predicted_ball, reset_reason, game_state):\n'
+ '        \n'
+ '        self.action.update_state(cur_posture, prev_posture, cur_ball, prev_ball, reset_reason)\n'
+ '\n'
+ '        action = None\n';

var PLAYERS_P6 = 
'\n'
+ '        return action if action != None else self.action.stop()\n';

var MAIN = 
'#!/usr/bin/env python3\n'
+ '\n'
+ '# Author(s): Taeyoung Kim, Chansol Hong, Luiz Felipe Vecchietti\n'
+ '# Maintainer: Chansol Hong (cshong@rit.kaist.ac.kr)\n'
+ '\n'
+ 'import os\n'
+ 'import sys\n'
+ '\n'
+ 'sys.path.append(os.path.dirname(os.path.realpath(__file__)) + \'/../common\')\n'
+ 'try:\n'
+ '    from participant import Participant, Game, Frame\n'
+ 'except ImportError as err:\n'
+ '    print(\'player_rulebasedC: "participant" module cannot be imported:\', err)\n'
+ '    raise\n'
+ '\n'
+ 'import math\n'
+ 'import numpy as np\n'
+ '\n'
+ 'import helper\n'
+ '\n'
+ 'from players import Goalkeeper, Defender_1, Defender_2, Forward_1, Forward_2\n'
+ '\n'
+ '#reset_reason\n'
+ 'NONE = Game.NONE\n'
+ 'GAME_START = Game.GAME_START\n'
+ 'SCORE_MYTEAM = Game.SCORE_MYTEAM\n'
+ 'SCORE_OPPONENT = Game.SCORE_OPPONENT\n'
+ 'GAME_END = Game.GAME_END\n'
+ 'DEADLOCK = Game.DEADLOCK\n'
+ 'GOALKICK = Game.GOALKICK\n'
+ 'CORNERKICK = Game.CORNERKICK\n'
+ 'PENALTYKICK = Game.PENALTYKICK\n'
+ 'HALFTIME = Game.HALFTIME\n'
+ 'EPISODE_END = Game.EPISODE_END\n'
+ '\n'
+ '#game_state\n'
+ 'STATE_DEFAULT = Game.STATE_DEFAULT\n'
+ 'STATE_KICKOFF = Game.STATE_KICKOFF\n'
+ 'STATE_GOALKICK = Game.STATE_GOALKICK\n'
+ 'STATE_CORNERKICK = Game.STATE_CORNERKICK\n'
+ 'STATE_PENALTYKICK = Game.STATE_PENALTYKICK\n'
+ '\n'
+ '#coordinates\n'
+ 'MY_TEAM = Frame.MY_TEAM\n'
+ 'OP_TEAM = Frame.OP_TEAM\n'
+ 'BALL = Frame.BALL\n'
+ 'X = Frame.X\n'
+ 'Y = Frame.Y\n'
+ 'Z = Frame.Z\n'
+ 'TH = Frame.TH\n'
+ 'ACTIVE = Frame.ACTIVE\n'
+ 'TOUCH = Frame.TOUCH\n'
+ 'BALL_POSSESSION = Frame.BALL_POSSESSION\n'
+ '        \n'
+ 'class Frame(object): \n'
+ '    def __init__(self):\n'
+ '        self.time = None\n'
+ '        self.score = None\n'
+ '        self.reset_reason = None\n'
+ '        self.game_state = None\n'
+ '        self.subimages = None\n'
+ '        self.coordinates = None\n'
+ '        self.half_passed = None\n'
+ '\n'
+ 'class Player(Participant):\n'
+ '    def init(self, info): \n'
+ '        self.field = info[\'field\']\n'
+ '        self.max_linear_velocity = info[\'max_linear_velocity\']\n'
+ '        self.robot_size = info[\'robot_size\'][0]\n'
+ '        self.goal = info[\'goal\']\n'
+ '        self.penalty_area = info[\'penalty_area\']\n'
+ '        self.goal_area = info[\'goal_area\']\n'
+ '        self.number_of_robots = info[\'number_of_robots\']\n'
+ '        self.end_of_frame = False\n'
+ '        self._frame = 0 \n'
+ '        self.speeds = [0 for _ in range(30)]\n'
+ '        self.gk_speeds = [0 for _ in range(6)]\n'
+ '        self.d1_speeds = [0 for _ in range(6)]\n'
+ '        self.d2_speeds = [0 for _ in range(6)]\n'
+ '        self.f1_speeds = [0 for _ in range(6)]\n'
+ '        self.f2_speeds = [0 for _ in range(6)]\n'
+ '        self.cur_posture = []\n'
+ '        self.cur_posture_opp = []\n'
+ '        self.cur_ball = []\n'
+ '        self.previous_ball = []\n'
+ '        self.previous_posture = []\n'
+ '        self.previous_posture_opp = []\n'
+ '        self.predicted_ball = []\n'
+ '        self.idx = 0\n'
+ '        self.idx_opp = 0\n'
+ '        self.previous_frame = Frame()\n'
+ '        self.defense_angle = 0\n'
+ '        self.attack_angle = 0\n'
+ '        self.GK = Goalkeeper(self.field, self.goal, self.penalty_area,\n'
+ '                            self.goal_area, self.robot_size,\n'
+ '                            self.max_linear_velocity)\n'
+ '        self.D1 = Defender_1(self.field, self.goal, self.penalty_area,\n'
+ '                            self.goal_area, self.robot_size,\n'
+ '                            self.max_linear_velocity)\n'
+ '        self.D2 = Defender_2(self.field, self.goal, self.penalty_area,\n'
+ '                            self.goal_area, self.robot_size,\n'
+ '                            self.max_linear_velocity)\n'
+ '        self.F1 = Forward_1(self.field, self.goal, self.penalty_area,\n'
+ '                            self.goal_area, self.robot_size,\n'
+ '                            self.max_linear_velocity)\n'
+ '        self.F2 = Forward_2(self.field, self.goal, self.penalty_area,\n'
+ '                            self.goal_area, self.robot_size,\n'
+ '                            self.max_linear_velocity)\n'
+ '        helper.printConsole("Initializing variables...")\n'
+ '\n'
+ '    def get_coord(self, received_frame):\n'
+ '        self.cur_ball = received_frame.coordinates[BALL]\n'
+ '        self.cur_posture = received_frame.coordinates[MY_TEAM]\n'
+ '        self.cur_posture_opp = received_frame.coordinates[OP_TEAM]\n'
+ '\n'
+ '    def update(self, received_frame):\n'
+ '\n'
+ '        if (received_frame.end_of_frame):\n'
+ '	    \n'
+ '            self._frame += 1\n'
+ '\n'
+ '            if (self._frame == 1):\n'
+ '                self.previous_frame = received_frame\n'
+ '                self.get_coord(received_frame)\n'
+ '                self.previous_ball = self.cur_ball\n'
+ '                self.previous_posture = self.cur_posture\n'
+ '                self.previous_posture_opp = self.cur_posture_opp\n'
+ '\n'
+ '            self.get_coord(received_frame)\n'
+ '            self.predicted_ball = helper.predict_ball(self.cur_ball, self.previous_ball, received_frame.reset_reason)\n'
+ '            self.idx = helper.find_closest_robot(self.cur_ball, self.cur_posture, self.number_of_robots)\n'
+ '            self.idx_opp = helper.find_closest_robot(self.cur_ball, self.cur_posture_opp, self.number_of_robots)\n'
+ '            self.defense_angle = helper.get_defense_kick_angle(self.predicted_ball, self.field, self.cur_ball)\n'
+ '            self.attack_angle = helper.get_attack_kick_angle(self.predicted_ball, self.field)\n'
+ '\n'
+ '##############################################################################\n'
+ '            #(update the robots wheels)\n'
+ '            self.gk_speeds = self.GK.move(self.idx, self.idx_opp, \n'
+ '                                            self.defense_angle, self.attack_angle,\n'
+ '                                            self.cur_posture, self.cur_posture_opp,\n'
+ '                                            self.previous_posture, self.previous_posture_opp,\n'
+ '                                            self.previous_ball, self.cur_ball, self.predicted_ball,\n'
+ '                                            received_frame.reset_reason, received_frame.game_state)\n'
+ '            self.d1_speeds = self.D1.move(self.idx, self.idx_opp, \n'
+ '                                            self.defense_angle, self.attack_angle,\n'
+ '                                            self.cur_posture, self.cur_posture_opp,\n'
+ '                                            self.previous_posture, self.previous_posture_opp,\n'
+ '                                            self.previous_ball, self.cur_ball, self.predicted_ball,\n'
+ '                                            received_frame.reset_reason, received_frame.game_state)\n'
+ '            self.d2_speeds = self.D2.move(self.idx, self.idx_opp, \n'
+ '                                            self.defense_angle, self.attack_angle,\n'
+ '                                            self.cur_posture, self.cur_posture_opp,\n'
+ '                                            self.previous_posture, self.previous_posture_opp,\n'
+ '                                            self.previous_ball, self.cur_ball, self.predicted_ball,\n'
+ '                                            received_frame.reset_reason, received_frame.game_state)\n'
+ '            self.f1_speeds = self.F1.move(self.idx, self.idx_opp, \n'
+ '                                            self.defense_angle, self.attack_angle,\n'
+ '                                            self.cur_posture, self.cur_posture_opp,\n'
+ '                                            self.previous_posture, self.previous_posture_opp,\n'
+ '                                            self.previous_ball, self.cur_ball, self.predicted_ball,\n'
+ '                                            received_frame.reset_reason, received_frame.game_state)\n'
+ '            self.f2_speeds = self.F2.move(self.idx, self.idx_opp, \n'
+ '                                            self.defense_angle, self.attack_angle,\n'
+ '                                            self.cur_posture, self.cur_posture_opp,\n'
+ '                                            self.previous_posture, self.previous_posture_opp,\n'
+ '                                            self.previous_ball, self.cur_ball, self.predicted_ball,\n'
+ '                                            received_frame.reset_reason, received_frame.game_state)\n'
+ '            self.speeds = self.gk_speeds + self.d1_speeds + self.d2_speeds + self.f1_speeds + self.f2_speeds\n'
+ '            self.set_speeds(self.speeds)\n'
+ '##############################################################################\n'
+ '\n'
+ '            self.previous_frame = received_frame\n'
+ '            self.previous_ball = self.cur_ball\n'
+ '            self.previous_posture = self.cur_posture\n'
+ '            self.previous_posture_opp = self.cur_posture_opp\n'
+ '\n'
+ 'if __name__ == \'__main__\':\n'
+ '    player = Player()\n'
+ '    player.run()\n';

var HELPER =
'#!/usr/bin/env python3\n'
+ '\n'
+ '# Author(s): Taeyoung Kim, Chansol Hong, Luiz Felipe Vecchietti\n'
+ '# Maintainer: Chansol Hong (cshong@rit.kaist.ac.kr)\n'
+ '\n'
+ 'import os\n'
+ 'import sys\n'
+ 'sys.path.append(os.path.dirname(os.path.realpath(__file__)) + \'/../common\')\n'
+ 'try:\n'
+ '    from participant import Game, Frame\n'
+ 'except ImportError as err:\n'
+ '    print(\'player_rulebasedC: "participant" module cannot be imported:\', err)\n'
+ '    raise\n'
+ '\n'
+ 'import math\n'
+ '\n'
+ '#reset_reason\n'
+ 'NONE = Game.NONE\n'
+ 'GAME_START = Game.GAME_START\n'
+ 'SCORE_MYTEAM = Game.SCORE_MYTEAM\n'
+ 'SCORE_OPPONENT = Game.SCORE_OPPONENT\n'
+ 'GAME_END = Game.GAME_END\n'
+ 'DEADLOCK = Game.DEADLOCK\n'
+ 'GOALKICK = Game.GOALKICK\n'
+ 'CORNERKICK = Game.CORNERKICK\n'
+ 'PENALTYKICK = Game.PENALTYKICK\n'
+ 'HALFTIME = Game.HALFTIME\n'
+ 'EPISODE_END = Game.EPISODE_END\n'
+ '\n'
+ '#game_state\n'
+ 'STATE_DEFAULT = Game.STATE_DEFAULT\n'
+ 'STATE_KICKOFF = Game.STATE_KICKOFF\n'
+ 'STATE_GOALKICK = Game.STATE_GOALKICK\n'
+ 'STATE_CORNERKICK = Game.STATE_CORNERKICK\n'
+ 'STATE_PENALTYKICK = Game.STATE_PENALTYKICK\n'
+ '\n'
+ '#coordinates\n'
+ 'MY_TEAM = Frame.MY_TEAM\n'
+ 'OP_TEAM = Frame.OP_TEAM\n'
+ 'BALL = Frame.BALL\n'
+ 'X = Frame.X\n'
+ 'Y = Frame.Y\n'
+ 'Z = Frame.Z\n'
+ 'TH = Frame.TH\n'
+ 'ACTIVE = Frame.ACTIVE\n'
+ 'TOUCH = Frame.TOUCH\n'
+ 'BALL_POSSESSION = Frame.BALL_POSSESSION\n'
+ '\n'
+ 'G = 9.81\n'
+ '\n'
+ 'def distance(x1, x2, y1, y2):\n'
+ '    return math.sqrt(math.pow(x1 - x2, 2) + math.pow(y1 - y2, 2))\n'
+ '\n'
+ 'def degree2radian(deg):\n'
+ '    return deg * math.pi / 180\n'
+ '\n'
+ 'def radian2degree(rad):\n'
+ '    return rad * 180 / math.pi\n'
+ '\n'
+ 'def wrap_to_pi(theta):\n'
+ '    while (theta > math.pi):\n'
+ '        theta -= 2 * math.pi\n'
+ '    while (theta < -math.pi):\n'
+ '        theta += 2 * math.pi\n'
+ '    return theta\n'
+ '\n'
+ 'def predict_ball(cur_ball, previous_ball, reset_reason, prediction_step = 1):\n'
+ '    if reset_reason > 0:\n'
+ '        predicted_ball = cur_ball\n'
+ '    else:\n'
+ '        dx = cur_ball[X] - previous_ball[X]\n'
+ '        dy = cur_ball[Y] - previous_ball[Y]\n'
+ '        dz = cur_ball[Z] - previous_ball[Z]\n'
+ '        predicted_ball = [cur_ball[X] + prediction_step*dx, cur_ball[Y] + prediction_step*dy, max(0.05, cur_ball[Z] + prediction_step*dz -(G*0.05*prediction_step*0.05*prediction_step)/2)]\n'
+ '    return predicted_ball\n'
+ '\n'
+ 'def find_closest_robot(cur_ball, cur_posture, number_of_robots):\n'
+ '    min_idx = 0\n'
+ '    min_distance = 9999.99\n'
+ '    for i in range(number_of_robots):\n'
+ '        measured_distance = distance(cur_ball[X], cur_posture[i][X], cur_ball[Y], cur_posture[i][Y])\n'
+ '        if (measured_distance < min_distance):\n'
+ '            min_distance = measured_distance\n'
+ '            min_idx = i\n'
+ '    if (min_idx == 0):\n'
+ '        idx = 1\n'
+ '    else:\n'
+ '        idx = min_idx\n'
+ '    return idx\n'
+ '\n'
+ 'def find_closest_opp_robot(robot_id, cur_posture, cur_posture_opp, number_of_robots):\n'
+ '    min_idx = 0\n'
+ '    min_distance = 9999.99\n'
+ '    for i in range(number_of_robots):\n'
+ '        measured_distance = distance(cur_posture[robot_id][X], cur_posture_opp[i][X], cur_posture[robot_id][Y], cur_posture_opp[i][Y])\n'
+ '        if (measured_distance < min_distance):\n'
+ '            min_distance = measured_distance\n'
+ '            min_idx = i\n'
+ '    return min_distance\n'
+ '\n'
+ 'def predict_robot_velocity(cur_posture, prev_posture, index, ts):\n'
+ '    vx = (cur_posture[index][X] - prev_posture[index][X])/ts\n'
+ '    vy = (cur_posture[index][Y] - prev_posture[index][Y])/ts\n'
+ '    return [vx, vy]\n'
+ '\n'
+ 'def predict_ball_velocity(cur_ball, prev_ball, ts, reset_reason):\n'
+ '    if reset_reason > 0:\n'
+ '        vx = 0\n'
+ '        vy = 0\n'
+ '        vz = 0\n'
+ '    else:\n'
+ '        vx = (cur_ball[X] - prev_ball[X])/ts\n'
+ '        vy = (cur_ball[Y] - prev_ball[Y])/ts\n'
+ '        vz = (cur_ball[Z] - prev_ball[Z])/ts\n'
+ '    return [vx, vy, vz]\n'
+ '\n'
+ '# Field Regions\n'
+ '\n'
+ 'def ball_is_own_goal(predicted_ball, field, goal_area):\n'
+ '    return (-field[X]/2 <= predicted_ball[X] <= -field[X]/2 + goal_area[X] and\n'
+ '            -goal_area[Y]/2 <= predicted_ball[Y] <= goal_area[Y]/2)\n'
+ '\n'
+ 'def ball_is_own_penalty(predicted_ball, field, penalty_area):\n'
+ '    return (-field[X]/2 <= predicted_ball[X] <= -field[X]/2 + penalty_area[X] and\n'
+ '    	-penalty_area[Y]/2 <= predicted_ball[Y] <=  penalty_area[Y]/2)\n'
+ '\n'
+ 'def ball_is_own_field(predicted_ball):\n'
+ '    return (predicted_ball[X] <= 0)\n'
+ '\n'
+ 'def ball_is_opp_goal(predicted_ball, field, goal_area):\n'
+ '    return (field[X]/2  - goal_area[X] <= predicted_ball[X] <= field[X]/2 and\n'
+ '            -goal_area[Y]/2 <= predicted_ball[Y] <= goal_area[Y]/2)\n'
+ '\n'
+ 'def ball_is_opp_penalty(predicted_ball, field, penalty_area):\n'
+ '    return (field[X]/2  - penalty_area[X] <= predicted_ball[X] <= field[X]/2 and\n'
+ '            -penalty_area[Y]/2 <= predicted_ball[Y] <= penalty_area[Y]/2)\n'
+ '\n'
+ 'def ball_is_opp_field(predicted_ball):\n'
+ '    return (predicted_ball[X] > 0)\n'
+ '\n'
+ '# Player Zone Regions\n'
+ '\n'
+ 'def ball_is_gk_zone(predicted_ball, field, goal_area):\n'
+ '    return (-field[X]/2 <= predicted_ball[X] <= -field[X]/2 + goal_area[X] +0.1 and\n'
+ '            -goal_area[Y]/2 - 0.1 <= predicted_ball[Y] <= goal_area[Y]/2 + 0.1)\n'
+ '\n'
+ 'def ball_is_d1_zone(predicted_ball, field, penalty_area):\n'
+ '    return (-field[X]/2 <= predicted_ball[X] <= -field[X]/2 + penalty_area[X] + 0.8 and\n'
+ '    	-penalty_area[Y]/2 - 0.3 <= predicted_ball[Y] <=  penalty_area[Y]/2 + 0.3)\n'
+ '\n'
+ 'def ball_is_d2_zone(predicted_ball, field):\n'
+ '    if (predicted_ball[X] < 0):\n'
+ '        return (predicted_ball[Y] < 0)\n'
+ '    else:\n'
+ '        return (predicted_ball[Y] < -field[Y]/(2*2))\n'
+ '\n'
+ 'def ball_is_f1_zone(predicted_ball, field):\n'
+ '    if (predicted_ball[X] < 0):\n'
+ '        return (predicted_ball[Y] >= 0)\n'
+ '    else:\n'
+ '        return (predicted_ball[Y] >= field[Y]/(2*2))\n'
+ '\n'
+ 'def ball_is_f2_zone(predicted_ball, field):\n'
+ '        return (predicted_ball[X] >= 0 and predicted_ball[Y] >= -field[Y]/(2*3) and predicted_ball[Y] <= -field[Y]/(2*3))\n'
+ '\n'
+ '# State Functions\n'
+ '\n'
+ 'def is_state_default(game_state):\n'
+ '    return game_state == STATE_DEFAULT\n'
+ '\n'
+ 'def is_state_goalkick(game_state):\n'
+ '    return game_state == STATE_GOALKICK\n'
+ '\n'
+ 'def is_state_cornerkick(game_state):\n'
+ '    return game_state == STATE_CORNERKICK\n'
+ '\n'
+ 'def is_state_kickoff(game_state):\n'
+ '    return game_state == STATE_KICKOFF\n'
+ '\n'
+ 'def is_state_penaltykick(game_state):\n'
+ '    return game_state == STATE_PENALTYKICK\n'
+ '\n'
+ 'def is_closest_to_ball(robot_id, idx):\n'
+ '    return robot_id == idx\n'
+ '\n'
+ '# Robot proximity functions\n'
+ '\n'
+ 'def is_close_to_ball(cur_posture_robot, cur_ball, threshold=0.2):\n'
+ '    return (distance(cur_ball[X], cur_posture_robot[X], cur_ball[Y], cur_posture_robot[Y]) <= threshold)\n'
+ '\n'
+ 'def has_ball_possession(cur_posture_robot):\n'
+ '    return cur_posture_robot[BALL_POSSESSION]\n'
+ '\n'
+ 'def is_gk_in_goalcenter(cur_posture_gk, field):\n'
+ '    return -field[X]/2 - 0.05 < cur_posture_gk[X] < -field[X]/2 + 0.15 and -0.02 < cur_posture_gk[Y] < 0.02\n'
+ '\n'
+ 'def robot_in_front_of_ball(cur_posture_robot, predicted_ball):\n'
+ '    return (cur_posture_robot[X] > predicted_ball[X])\n'
+ '\n'
+ 'def get_defense_kick_angle(predicted_ball, field, cur_ball):\n'
+ '    if predicted_ball[X] >= -field[X] / 2:\n'
+ '        x = -field[X] / 2 - predicted_ball[X]\n'
+ '    else:\n'
+ '        x = -field[X] / 2 - cur_ball[X]\n'
+ '    y = predicted_ball[Y]\n'
+ '    return math.atan2(y, abs(x) + 0.00001)\n'
+ '\n'
+ 'def get_attack_kick_angle(predicted_ball, field):\n'
+ '    x = field[X] / 2 - predicted_ball[X] + 0.00001\n'
+ '    y = predicted_ball[Y]\n'
+ '    angle = math.atan2(y, x)\n'
+ '    return -angle\n'
+ '\n'
+ 'def set_wheel_velocity(max_linear_velocity, left_wheel, right_wheel):\n'
+ '    ratio_l = 1\n'
+ '    ratio_r = 1\n'
+ '\n'
+ '    if (left_wheel > max_linear_velocity or right_wheel > max_linear_velocity):\n'
+ '        diff = max(left_wheel, right_wheel) - max_linear_velocity\n'
+ '        left_wheel -= diff\n'
+ '        right_wheel -= diff\n'
+ '    if (left_wheel < -max_linear_velocity or right_wheel < -max_linear_velocity):\n'
+ '        diff = min(left_wheel, right_wheel) + max_linear_velocity\n'
+ '        left_wheel -= diff\n'
+ '        right_wheel -= diff\n'
+ '\n'
+ '    return left_wheel, right_wheel\n'
+ '\n'
+ 'def printConsole(message):\n'
+ '    print(message)\n'
+ '    sys.__stdout__.flush()\n';

var ACTION = 
'#!/usr/bin/env python3\n'
+ '\n'
+ '# Author(s): Taeyoung Kim, Chansol Hong, Luiz Felipe Vecchietti\n'
+ '# Maintainer: Chansol Hong (cshong@rit.kaist.ac.kr)\n'
+ '\n'
+ 'import os\n'
+ 'import sys\n'
+ 'sys.path.append(os.path.dirname(os.path.realpath(__file__)) + \'/../common\')\n'
+ 'try:\n'
+ '    from participant import Game, Frame\n'
+ 'except ImportError as err:\n'
+ '    print(\'player_rulebasedC: "participant" module cannot be imported:\', err)\n'
+ '    raise\n'
+ '\n'
+ 'import math\n'
+ 'import helper\n'
+ '\n'
+ 'from scipy.optimize import fsolve\n'
+ 'import warnings\n'
+ 'warnings.filterwarnings(\'ignore\', \'The iteration is not making good progress\')\n'
+ '\n'
+ '#reset_reason\n'
+ 'NONE = Game.NONE\n'
+ 'GAME_START = Game.GAME_START\n'
+ 'SCORE_MYTEAM = Game.SCORE_MYTEAM\n'
+ 'SCORE_OPPONENT = Game.SCORE_OPPONENT\n'
+ 'GAME_END = Game.GAME_END\n'
+ 'DEADLOCK = Game.DEADLOCK\n'
+ 'GOALKICK = Game.GOALKICK\n'
+ 'CORNERKICK = Game.CORNERKICK\n'
+ 'PENALTYKICK = Game.PENALTYKICK\n'
+ 'HALFTIME = Game.HALFTIME\n'
+ 'EPISODE_END = Game.EPISODE_END\n'
+ '\n'
+ '#game_state\n'
+ 'STATE_DEFAULT = Game.STATE_DEFAULT\n'
+ 'STATE_KICKOFF = Game.STATE_KICKOFF\n'
+ 'STATE_GOALKICK = Game.STATE_GOALKICK\n'
+ 'STATE_CORNERKICK = Game.STATE_CORNERKICK\n'
+ 'STATE_PENALTYKICK = Game.STATE_PENALTYKICK\n'
+ '\n'
+ '#coordinates\n'
+ 'MY_TEAM = Frame.MY_TEAM\n'
+ 'OP_TEAM = Frame.OP_TEAM\n'
+ 'BALL = Frame.BALL\n'
+ 'X = Frame.X\n'
+ 'Y = Frame.Y\n'
+ 'Z = Frame.Z\n'
+ 'TH = Frame.TH\n'
+ 'ACTIVE = Frame.ACTIVE\n'
+ 'TOUCH = Frame.TOUCH\n'
+ 'BALL_POSSESSION = Frame.BALL_POSSESSION\n'
+ '\n'
+ 'class ActionControl:\n'
+ '\n'
+ '    def __init__(self, robot_id, max_linear_velocity):\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '        self.g = 9.81 # gravity\n'
+ '        self.damping = 0.2 # linear damping\n'
+ '        self.mult_fs = 0.75 \n'
+ '        self.max_kick_speed = 10*self.mult_fs # 7.5 m/s\n'
+ '        self.mult_angle = 5\n'
+ '        self.max_kick_angle = 10*self.mult_angle # 50 degrees\n'
+ '\n'
+ '        self.robot_id = robot_id\n'
+ '        self.cur_posture = []\n'
+ '        self.prev_posture = []\n'
+ '        self.cur_posture_opp = []\n'
+ '        self.prev_posture_opp = []\n'
+ '        self.cur_ball = []\n'
+ '        self.prev_ball = []\n'
+ '        self.reset_reason = NONE\n'
+ '\n'
+ '    def update_state(self, cur_posture, prev_posture, cur_ball, prev_ball, reset_reason):\n'
+ '        self.cur_posture = cur_posture\n'
+ '        self.prev_posture = prev_posture\n'
+ '        self.cur_ball = cur_ball\n'
+ '        self.prev_ball = prev_ball\n'
+ '        self.reset_reason = reset_reason\n'
+ '\n'
+ '    def stop(self):\n'
+ '        return [0, 0, 0, 0, 0, 0]\n'
+ '\n'
+ '    def manual_control(self, left_wheel, right_wheel, kick_speed, kick_angle, jump_speed, dribble_mode):\n'
+ '        return [left_wheel, right_wheel, kick_speed, kick_angle, jump_speed, dribble_mode]\n'
+ '\n'
+ '    def jump(self):\n'
+ '        return [0, 0, 0, 0, 10, 0]\n'
+ '\n'
+ '    def go_to(self, x, y):\n'
+ '        sign = 1\n'
+ '        kd = 7 if ((self.robot_id == 1) or (self.robot_id == 2)) else 5\n'
+ '        ka = 0.3\n'
+ '\n'
+ '        tod = 0.005 # tolerance of distance\n'
+ '        tot = math.pi/360 # tolerance of theta\n'
+ '\n'
+ '        dx = x - self.cur_posture[self.robot_id][X]\n'
+ '        dy = y - self.cur_posture[self.robot_id][Y]\n'
+ '        d_e = math.sqrt(math.pow(dx, 2) + math.pow(dy, 2))\n'
+ '        desired_th = math.atan2(dy, dx)\n'
+ '\n'
+ '        d_th = helper.wrap_to_pi(desired_th - self.cur_posture[self.robot_id][TH])\n'
+ '        \n'
+ '        if (d_th > helper.degree2radian(90)):\n'
+ '            d_th -= math.pi\n'
+ '            sign = -1\n'
+ '        elif (d_th < helper.degree2radian(-90)):\n'
+ '            d_th += math.pi\n'
+ '            sign = -1\n'
+ '\n'
+ '        if (d_e < tod):\n'
+ '            kd = 0\n'
+ '        if (abs(d_th) < tot):\n'
+ '            ka = 0\n'
+ '\n'
+ '        if self.go_fast():\n'
+ '            kd *= 5\n'
+ '\n'
+ '        left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity[self.robot_id],\n'
+ '                    sign * (kd * d_e - ka * d_th), \n'
+ '                    sign * (kd * d_e + ka * d_th))\n'
+ '\n'
+ '        return [left_wheel, right_wheel, 0, 0, 0, 1]\n'
+ '\n'
+ '    def go_fast(self):\n'
+ '        distance2ball = helper.distance(self.cur_ball[X], self.cur_posture[self.robot_id][X],\n'
+ '                                    self.cur_ball[Y], self.cur_posture[self.robot_id][Y])\n'
+ '        d_bg = helper.distance(self.cur_ball[X], 3.9,\n'
+ '                                    self.cur_ball[Y], 0)\n'
+ '        d_rg = helper.distance(3.9, self.cur_posture[self.robot_id][X],\n'
+ '                                    0, self.cur_posture[self.robot_id][Y])\n'
+ '        \n'
+ '        if (distance2ball < 0.25 and d_rg > d_bg):\n'
+ '            if (self.cur_ball[X] > 3.7 and abs(self.cur_ball[Y]) > 0.5 and abs(self.cur_posture[self.robot_id][TH]) < 30 * math.pi/180):\n'
+ '                return False\n'
+ '            else:\n'
+ '                return True\n'
+ '        else:\n'
+ '            return False\n'
+ '\n'
+ '    def turn_to(self, x, y):\n'
+ '        ka = 0.2\n'
+ '        tot = math.pi/360\n'
+ '\n'
+ '        dx = x - self.cur_posture[self.robot_id][X]\n'
+ '        dy = y - self.cur_posture[self.robot_id][Y]\n'
+ '        desired_th = math.atan2(dy, dx)\n'
+ '        d_th = helper.wrap_to_pi(desired_th - self.cur_posture[self.robot_id][TH])\n'
+ '        \n'
+ '        if (abs(d_th) < tot):\n'
+ '            ka = 0\n'
+ '        \n'
+ '        left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity[self.robot_id],\n'
+ '                                                                -ka*d_th,\n'
+ '                                                                ka*d_th)\n'
+ '\n'
+ '        return [left_wheel, right_wheel, 0, 0, 0 , 1]\n'
+ '\n'
+ '    def defend_ball(self):\n'
+ '        if self.robot_id != 0:\n'
+ '            return None\n'
+ '        if self.reset_reason != NONE:\n'
+ '            return None\n'
+ '\n'
+ '        # GK takes 250ms to perform defense move\n'
+ '        predicted_ball_gk = helper.predict_ball(self.cur_ball, self.prev_ball, self.reset_reason, 5)\n'
+ '\n'
+ '        if predicted_ball_gk[X] < self.cur_posture[self.robot_id][X] + 0.1:\n'
+ '            # right part of the goal\n'
+ '            if -0.65 < predicted_ball_gk[Y] < -0.07:\n'
+ '                # top part of the goal\n'
+ '                if (predicted_ball_gk[Z] > 0.25):\n'
+ '                    return [0, 0, 0, 0, 7, 0]\n'
+ '                else:\n'
+ '                    return [0, 0, 0, 0, 6, 0]\n'
+ '            # center part of the goal\n'
+ '            if -0.07 < predicted_ball_gk[Y] < 0.07:\n'
+ '                # top part of the goal\n'
+ '                if (predicted_ball_gk[Z] > 0.25):\n'
+ '                    return [0, 0, 0, 0, 8, 0]\n'
+ '                else:\n'
+ '                    return [0, 0, 0, 0, 3, 0]\n'
+ '            # left part of the goal\n'
+ '            if 0.07 < predicted_ball_gk[Y] < 0.65:\n'
+ '                # top part of the goal\n'
+ '                if (predicted_ball_gk[Z] > 0.25):\n'
+ '                    return [0, 0, 0, 0, 9, 0]\n'
+ '                else:\n'
+ '                    return [0, 0, 0, 0, 10, 0]\n'
+ '        else:\n'
+ '            return None\n'
+ '\n'
+ '    def is_gk_save_possible(self):\n'
+ '        return self.defend_ball() != None\n'
+ '\n'
+ '    def pass_to(self, x, y):\n'
+ '        \n'
+ '        dist = helper.distance(self.cur_posture[self.robot_id][X], x, self.cur_posture[self.robot_id][Y], y)\n'
+ '        kick_speed = (7 + 1.5 * (dist / 5.07))*self.mult_fs\n'
+ '        kick_angle = 0\n'
+ '\n'
+ '        direction = math.atan2(y - self.cur_posture[self.robot_id][Y], x - self.cur_posture[self.robot_id][X]) * 4 / math.pi\n'
+ '        if direction > 4:\n'
+ '            direction -= 8\n'
+ '\n'
+ '        if abs(self.cur_posture[self.robot_id][TH] - math.pi / 4 * direction) > math.pi:\n'
+ '            if 0 <= abs(2 * math.pi + self.cur_posture[self.robot_id][TH] - math.pi / 4 * direction) <= math.pi:\n'
+ '                self.cur_posture[self.robot_id][TH] += 2 * math.pi\n'
+ '            else:\n'
+ '                self.cur_posture[self.robot_id][TH] -= 2 * math.pi\n'
+ '\n'
+ '        if self.cur_posture[self.robot_id][TH] > math.pi / 4 * direction:\n'
+ '            if self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction > 5:\n'
+ '                w = min(1, (self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction) / (70 * self.max_linear_velocity[self.robot_id] / self.max_linear_velocity[0]))\n'
+ '                if helper.distance(self.cur_posture[self.robot_id][X], self.prev_posture[self.robot_id][X], self.cur_posture[self.robot_id][Y], self.prev_posture[self.robot_id][Y]) < 0.01: # corner case\n'
+ '                    return [w/2, -w/2, 0, 0, 0, 1]\n'
+ '                return [0.4 + w/2, 0.4 - w/2, 0, 0, 0, 1]\n'
+ '            else:\n'
+ '                return [1, 1, kick_speed, kick_angle, 0, 1]\n'
+ '        else:\n'
+ '            if self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction < -5:\n'
+ '                w = min(1, -(self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction) / (70 * self.max_linear_velocity[self.robot_id] / self.max_linear_velocity[0]))\n'
+ '                if helper.distance(self.cur_posture[self.robot_id][X], self.prev_posture[self.robot_id][X], self.cur_posture[self.robot_id][Y], self.prev_posture[self.robot_id][Y]) < 0.01:\n'
+ '                    return [-w/2, w/2, 0, 0, 0, 1]\n'
+ '                return [0.4 - w/2, 0.4 + w/2, 0, 0, 0, 1]\n'
+ '            else:\n'
+ '                return [1, 1, kick_speed, kick_angle, 0, 1]\n'
+ '\n'
+ '    def pass_to_robot(self, target_robot_id):\n'
+ '        \n'
+ '        x = self.cur_posture[target_robot_id][X]\n'
+ '        y = self.cur_posture[target_robot_id][Y]\n'
+ '        \n'
+ '        dist = helper.distance(self.cur_posture[self.robot_id][X], x, self.cur_posture[self.robot_id][Y], y)\n'
+ '        kick_speed = (7 + 1.5 * (dist / 5.07))*self.mult_fs\n'
+ '        kick_angle = 0\n'
+ '\n'
+ '        direction = math.atan2(y - self.cur_posture[self.robot_id][Y], x - self.cur_posture[self.robot_id][X]) * 4 / math.pi\n'
+ '        if direction > 4:\n'
+ '            direction -= 8\n'
+ '\n'
+ '        if abs(self.cur_posture[self.robot_id][TH] - math.pi / 4 * direction) > math.pi:\n'
+ '            if 0 <= abs(2 * math.pi + self.cur_posture[self.robot_id][TH] - math.pi / 4 * direction) <= math.pi:\n'
+ '                self.cur_posture[self.robot_id][TH] += 2 * math.pi\n'
+ '            else:\n'
+ '                self.cur_posture[self.robot_id][TH] -= 2 * math.pi\n'
+ '\n'
+ '        if self.cur_posture[self.robot_id][TH] > math.pi / 4 * direction:\n'
+ '            if self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction > 5:\n'
+ '                w = min(1, (self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction) / (70 * self.max_linear_velocity[self.robot_id] / self.max_linear_velocity[0]))\n'
+ '                if helper.distance(self.cur_posture[self.robot_id][X], self.prev_posture[self.robot_id][X], self.cur_posture[self.robot_id][Y], self.prev_posture[self.robot_id][Y]) < 0.01: # corner case\n'
+ '                    return [w/2, -w/2, 0, 0, 0, 1]\n'
+ '                return [0.4 + w/2, 0.4 - w/2, 0, 0, 0, 1]\n'
+ '            else:\n'
+ '                return [1, 1, kick_speed, kick_angle, 0, 1]\n'
+ '        else:\n'
+ '            if self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction < -5:\n'
+ '                w = min(1, -(self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction) / (70 * self.max_linear_velocity[self.robot_id] / self.max_linear_velocity[0]))\n'
+ '                if helper.distance(self.cur_posture[self.robot_id][X], self.prev_posture[self.robot_id][X], self.cur_posture[self.robot_id][Y], self.prev_posture[self.robot_id][Y]) < 0.01:\n'
+ '                    return [-w/2, w/2, 0, 0, 0, 1]\n'
+ '                return [0.4 - w/2, 0.4 + w/2, 0, 0, 0, 1]\n'
+ '            else:\n'
+ '                return [1, 1, kick_speed, kick_angle, 0, 1]\n'
+ '\n'
+ '    def cross_to(self, x, y, z):\n'
+ '        \n'
+ '        dist = helper.distance(self.cur_posture[self.robot_id][X], x, self.cur_posture[self.robot_id][Y], y)\n'
+ '        max_cross_angle = 40\n'
+ '\n'
+ '        if self.damping == 0:\n'
+ '            try:\n'
+ '                theta = math.pi*max_cross_angle/180\n'
+ '                v0 = math.sqrt((self.g * dist * dist) / (2 * (math.cos(theta) ** 2) * (dist * math.tan(theta) - z)))\n'
+ '                while v0 > self.max_kick_speed:\n'
+ '                    theta -= math.pi / 180\n'
+ '                    v0 = math.sqrt((self.g * dist * dist) / (2 * (math.cos(theta) ** 2) * (dist * math.tan(theta) - z)))\n'
+ '            except ValueError as e:\n'
+ '                #helper.printConsole(e)\n'
+ '                return None\n'
+ '        else:\n'
+ '            try:\n'
+ '                theta = math.pi*max_cross_angle/180\n'
+ '                while True:\n'
+ '                    relative_height_for_time = lambda t: (-self.g * t / self.damping) + self.g * (1 - math.exp(-self.damping*t)) / (self.damping**2) + dist * math.tan(theta) - (z - self.cur_ball[Z])\n'
+ '                    t = float(fsolve(relative_height_for_time, 2))\n'
+ '                    vx0 = dist * self.damping / (1 - math.exp(-self.damping * t))\n'
+ '                    vy0 = vx0 * math.tan(theta)\n'
+ '                    v0 = math.sqrt(vx0 ** 2 + vy0 ** 2)\n'
+ '                    if v0 > self.max_kick_speed:\n'
+ '                        theta -= math.pi / 180\n'
+ '                        if theta < 0:\n'
+ '                            return None\n'
+ '                        continue\n'
+ '                    break\n'
+ '            except ValueError as e:\n'
+ '                #helper.printConsole(e)\n'
+ '                return None\n'
+ '\n'
+ '        kick_speed = v0 / self.mult_fs\n'
+ '        kick_angle = theta * (180 / math.pi) / self.mult_angle\n'
+ '\n'
+ '        direction = math.atan2(y - self.cur_posture[self.robot_id][Y], x - self.cur_posture[self.robot_id][X]) * 4 / math.pi\n'
+ '        if direction > 4:\n'
+ '            direction -= 8\n'
+ '\n'
+ '        if abs(self.cur_posture[self.robot_id][TH] - math.pi / 4 * direction) > math.pi:\n'
+ '            if 0 <= abs(2 * math.pi + self.cur_posture[self.robot_id][TH] - math.pi / 4 * direction) <= math.pi:\n'
+ '                self.cur_posture[self.robot_id][TH] += 2 * math.pi\n'
+ '            else:\n'
+ '                self.cur_posture[self.robot_id][TH] -= 2 * math.pi\n'
+ '\n'
+ '        if self.cur_posture[self.robot_id][TH] > math.pi / 4 * direction:\n'
+ '            if self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction > 5:\n'
+ '                w = min(1, (self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction) / (70 * self.max_linear_velocity[self.robot_id] / self.max_linear_velocity[0]))\n'
+ '                return [w/2, -w/2, 0, 0, 0, 1]\n'
+ '            else:\n'
+ '                if kick_angle > 10:\n'
+ '                    return [-1, -1, 0, 0, 0, 1]\n'
+ '                elif kick_speed > 10:\n'
+ '                    return [1, 1, 0, 0, 0, 1]\n'
+ '                else:\n'
+ '                    return [1, 1, kick_speed, kick_angle, 0, 1]\n'
+ '        else:\n'
+ '            if self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction < -5:\n'
+ '                w = min(1, -(self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction) / (70 * self.max_linear_velocity[self.robot_id] / self.max_linear_velocity[0]))\n'
+ '                return [-w/2, w/2, 0, 0, 0, 1]\n'
+ '            else:\n'
+ '                if kick_speed > 10:\n'
+ '                    return [1, 1, 0, 0, 0, 1]\n'
+ '                elif kick_angle > 10:\n'
+ '                    return [-1, -1, 0, 0, 0, 1]\n'
+ '                else:\n'
+ '                    return [1, 1, kick_speed, kick_angle, 0, 1]\n'
+ '\n'
+ '    def is_cross_to_possible(self, x, y, z):\n'
+ '        return self.cross_to(x, y, z) != None\n'
+ '\n'
+ '    def cross_to_robot(self, target_robot_id):\n'
+ '        \n'
+ '        x = self.cur_posture[target_robot_id][X]\n'
+ '        y = self.cur_posture[target_robot_id][Y]\n'
+ '        z = 0.421\n'
+ '\n'
+ '        dist = helper.distance(self.cur_posture[self.robot_id][X], x, self.cur_posture[self.robot_id][Y], y)\n'
+ '        max_cross_angle = 40\n'
+ '\n'
+ '        if self.damping == 0:\n'
+ '            try:\n'
+ '                theta = math.pi*max_cross_angle/180\n'
+ '                v0 = math.sqrt((self.g * dist * dist) / (2 * (math.cos(theta) ** 2) * (dist * math.tan(theta) - z)))\n'
+ '                while v0 > self.max_kick_speed:\n'
+ '                    theta -= math.pi / 180\n'
+ '                    v0 = math.sqrt((self.g * dist * dist) / (2 * (math.cos(theta) ** 2) * (dist * math.tan(theta) - z)))\n'
+ '            except ValueError as e:\n'
+ '                #helper.printConsole(e)\n'
+ '                return None\n'
+ '        else:\n'
+ '            try:\n'
+ '                theta = math.pi*max_cross_angle/180\n'
+ '                while True:\n'
+ '                    relative_height_for_time = lambda t: (-self.g * t / self.damping) + self.g * (1 - math.exp(-self.damping*t)) / (self.damping**2) + dist * math.tan(theta) - (z - self.cur_ball[Z])\n'
+ '                    t = float(fsolve(relative_height_for_time, 2))\n'
+ '                    vx0 = dist * self.damping / (1 - math.exp(-self.damping * t))\n'
+ '                    vy0 = vx0 * math.tan(theta)\n'
+ '                    v0 = math.sqrt(vx0 ** 2 + vy0 ** 2)\n'
+ '                    if v0 > self.max_kick_speed:\n'
+ '                        theta -= math.pi / 180\n'
+ '                        if theta < 0:\n'
+ '                            return None\n'
+ '                        continue\n'
+ '                    break\n'
+ '            except ValueError as e:\n'
+ '                #helper.printConsole(e)\n'
+ '                return None\n'
+ '\n'
+ '        kick_speed = v0 / self.mult_fs\n'
+ '        kick_angle = theta * (180 / math.pi) / self.mult_angle\n'
+ '\n'
+ '        direction = math.atan2(y - self.cur_posture[self.robot_id][Y], x - self.cur_posture[self.robot_id][X]) * 4 / math.pi\n'
+ '        if direction > 4:\n'
+ '            direction -= 8\n'
+ '\n'
+ '        if abs(self.cur_posture[self.robot_id][TH] - math.pi / 4 * direction) > math.pi:\n'
+ '            if 0 <= abs(2 * math.pi + self.cur_posture[self.robot_id][TH] - math.pi / 4 * direction) <= math.pi:\n'
+ '                self.cur_posture[self.robot_id][TH] += 2 * math.pi\n'
+ '            else:\n'
+ '                self.cur_posture[self.robot_id][TH] -= 2 * math.pi\n'
+ '\n'
+ '        if self.cur_posture[self.robot_id][TH] > math.pi / 4 * direction:\n'
+ '            if self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction > 5:\n'
+ '                w = min(1, (self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction) / (70 * self.max_linear_velocity[self.robot_id] / self.max_linear_velocity[0]))\n'
+ '                return [w/2, -w/2, 0, 0, 0, 1]\n'
+ '            else:\n'
+ '                if kick_angle > 10:\n'
+ '                    return [-1, -1, 0, 0, 0, 1]\n'
+ '                elif kick_speed > 10:\n'
+ '                    return [1, 1, 0, 0, 0, 1]\n'
+ '                else:\n'
+ '                    return [1, 1, kick_speed, kick_angle, 0, 1]\n'
+ '        else:\n'
+ '            if self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction < -5:\n'
+ '                w = min(1, -(self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction) / (70 * self.max_linear_velocity[self.robot_id] / self.max_linear_velocity[0]))\n'
+ '                return [-w/2, w/2, 0, 0, 0, 1]\n'
+ '            else:\n'
+ '                if kick_speed > 10:\n'
+ '                    return [1, 1, 0, 0, 0, 1]\n'
+ '                elif kick_angle > 10:\n'
+ '                    return [-1, -1, 0, 0, 0, 1]\n'
+ '                else:\n'
+ '                    return [1, 1, kick_speed, kick_angle, 0, 1]\n'
+ '\n'
+ '    def is_cross_to_robot_possible(self, target_robot_id):\n'
+ '        return self.cross_to_robot(target_robot_id) != None\n'
+ '\n'
+ '    def shoot_to(self, x, y, kick_speed=10, kick_angle=4):\n'
+ '\n'
+ '        direction = math.atan2(y - self.cur_posture[self.robot_id][Y], x - self.cur_posture[self.robot_id][X]) * 4 / math.pi\n'
+ '\n'
+ '        if direction > 4:\n'
+ '            direction -= 8\n'
+ '\n'
+ '        if abs(self.cur_posture[self.robot_id][TH] - math.pi / 4 * direction) > math.pi:\n'
+ '            if 0 <= abs(2 * math.pi + self.cur_posture[self.robot_id][TH] - math.pi / 4 * direction) <= math.pi:\n'
+ '                self.cur_posture[self.robot_id][TH] += 2 * math.pi\n'
+ '            else:\n'
+ '                self.cur_posture[self.robot_id][TH] -= 2 * math.pi\n'
+ '\n'
+ '        if self.cur_posture[self.robot_id][TH] > math.pi / 4 * direction:\n'
+ '            if self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction < 15:\n'
+ '                return [1, 1, kick_speed, kick_angle, 0, 1]\n'
+ '            else:\n'
+ '                w = min(1, (self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction) / (70 * self.max_linear_velocity[self.robot_id] / self.max_linear_velocity[0]))\n'
+ '                if helper.distance(self.cur_posture[self.robot_id][X], self.prev_posture[self.robot_id][X], self.cur_posture[self.robot_id][Y], self.prev_posture[self.robot_id][Y]) < 0.01: # corner case\n'
+ '                    return [w/2, -w/2, 0, 0, 0, 1]\n'
+ '                return [0.75 + w/2, 0.75 - w/2, 0, 0, 0, 1]\n'
+ '        else:\n'
+ '            if self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction > -15:\n'
+ '                return [1, 1, kick_speed, kick_angle, 0, 1]\n'
+ '            else:\n'
+ '                w = min(1, -(self.cur_posture[self.robot_id][TH] * 180 / math.pi - 45 * direction) / (70 * self.max_linear_velocity[self.robot_id] / self.max_linear_velocity[0]))\n'
+ '                if helper.distance(self.cur_posture[self.robot_id][X], self.prev_posture[self.robot_id][X], self.cur_posture[self.robot_id][Y], self.prev_posture[self.robot_id][Y]) < 0.01:\n'
+ '                    return [-w/2, w/2, 0, 0, 0, 1]\n'
+ '                return [0.75 - w/2, 0.75 + w/2, 0, 0, 0, 1]\n';